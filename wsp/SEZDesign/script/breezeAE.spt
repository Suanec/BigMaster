scala -J-Dcom.github.fommil.netlib.NativeSystemBLAS.natives=mkl_rt.dll -cp "D:\betn\Scala\ScalaSpace\breezeLib\breezeLib_2.11-assembly-natives-1.0.jar"

object breezeAE extends Serializable {
  import scala.collection.mutable.ArrayBuffer
  import scala.math._
  import java.util.concurrent.ThreadLocalRandom

  import breeze.linalg._
  import breeze.numerics._
  import scala.util.Random
  import breeze.linalg.{
    DenseMatrix => BDM,
    DenseVector => BDV,
    Vector => BrzVector, 
    SparseVector => BSV,
    sum
  }
  import breeze.numerics.{
    exp => BrzExp,
    tanh => BrzTanh,
    sigmoid => BrzSigmoid, 
    pow => BrzPow, 
    sqrt => BrzSqrt
  }
  import breeze.stats.distributions.{
    Gaussian => BrzGaussian
  }

  type SDM = BDM[Double]
  type SDV = BDV[Double]
  type SSV = BSV[Double]
  type SBRZV = BrzVector[Double]

  type SVector = Array[Double]
  type SWord = (Int,Int,Double) // col, row, value
  type SWordBuf = ArrayBuffer[SWord]
  type SDoc = Array[SWord]
  type SDocs = Array[SDoc]
  type SData = (Int, SDoc)
  var lr = 0.001
  val b = BDM(1d)

  def vertcat( _x : SDM, _y : SDM ) : SDM = {
    DenseMatrix.vertcat(_x, _y)
  }

  /// sigmoid(W * X + B )
  def wxpbS( _w : SDM, _x : SDM ) : SDM = {
    BrzSigmoid(_w * vertcat(_x, b))
  }

  def setLr(_lr : Double) = { lr = _lr }
  // type SDataSet = (Int, Int, RDD[SData])

  /**
   * 随机生成n2维数据
   * rows 行, cols 列，max 上限，min 下限，seed 随机种子
   * @author suanec
   */
  def RandM(
    rows : Int = 4,
    cols : Int = 3,
    max  : Double = 1.0,
    min  : Double = 0.0,
    seed : Long = 201512081552L): BDM[Double] = {
    // val rand = new Random(seed)
    val bdm_rand = BDM.tabulate[Double](rows, cols)((_, _) => ThreadLocalRandom.current().nextDouble(min,max))
    bdm_rand 
  }///   def RandM(

  /**
  生成随机矩阵，服从高斯分布
  */
  def gaussianM(
    _row : Int = 10,
    _col : Int = 7,
    _mu : Double = 0d,
    _sigma : Double = 1d) : SDM = {
    val gaussianRand = new BrzGaussian(_mu, _sigma)
    BDM.rand(_row, _col, gaussianRand)
  }

  /**
   * 将数组按行填充矩阵。
   * 
   */
  def arrFillMatByRow0(
    _row : Int,
    _col : Int,
    _data: Array[Double]) : SDM = {
    require(_row*_col <= _data.size, "target matrix too large, _data not enough!! == From boae.arrRowMat")
    BDM.tabulate[Double](_row,_col)((i,j) => _data( i*_col + j))
  }
  def arrFillMatByRow(
    _row : Int,
    _col : Int,
    _data: Array[Double]) : SDM = {
    require(_row*_col <= _data.size, "target matrix too large, _data not enough!! == From boae.arrRowMat")
    new SDM(_col, _row, _data).t.copy
  }
  def testArrFillMatByRowTime(_maxIter : Int = 10000 ) : String = {
    val data = gaussianM(9,7,0d,1d).data
    val start0 = System.nanoTime
    (0 to _maxIter).map( i => arrFillMatByRow0(9,7,data) )
    val end0 = System.nanoTime
    val time0 = end0 - start0
    val start1 = System.nanoTime
    (0 to _maxIter).map( i => arrFillMatByRow(9,7,data) )
    val end1 = System.nanoTime
    val time1 = end1 - start1
    val rst = (time1 > time0) match {
      case true => "arrFillMatByRow0"
      case false => "arrFillMatByRow"
    }
    println(rst)
    rst
  }
  
  /**
   * 自编码权值初始化函数
   * _size : 网络大小
   * max: 上限，min: 下限，seed: 随机种子
   * @author suanec
   */
  def InitWeight(
    _size  : Array[Int],
    _max   : Double = 0.5,
    _min   : Double = -0.5,
    _seed  : Long = 201512082245L) : (Array[SDM], Array[SDM]) = {
    val res = new Array[SDM](_size.size -1)
    res.indices.map{
      i => 
        res(i) = RandM(_size(i+1), _size(i) + 1,_max,_min,_seed)
    }
    res.splitAt(res.size / 2)
  }///   def InitWeight(
  def InitWeightGaussian(
    _size : Array[Int], 
    _mu : Double = 0d,
    _sigma : Double = 1d) : (Array[SDM], Array[SDM]) = {
    val res = new Array[SDM](_size.size -1)
    res.indices.map{
      i => 
        res(i) = gaussianM(_size(i+1), _size(i) + 1, _mu, _sigma)
    }
    res.splitAt(res.size / 2)
  }

  // def Dif_sigmoid( z : Double ) : Double = sigmoid(z) / ( 1 - sigmoid(z) )

  // def Dif_tanh( z : Double ) : Double = 1 - tanh(z) * tanh(z)

  // def MulDoc(_w : SDM,_doc : SDM):SDM = {_w * _doc}
  // MulDoc = w * x + b
  def MulDoc(
    _w : SDM,
    _doc : SDoc) : SDM = {
    val tSDM = new SDM(_w.rows,1)
    (0 until _w.rows).map{
      i =>
      (0 until _doc.size).map{
        j =>
        val rNum = _doc(j)._1 -1
        tSDM(i,0) += _w(i,rNum) * _doc(j)._3
      }
      tSDM(i,0) += _w(i,-1)
    }
    tSDM
  }
                                                                               
  def passAway(_w: Array[SDM], _doc : SSV ): Array[SDM] = {
    val newDoc = BSV.vertcat(_doc, BSV(1d))
    val z = BrzSigmoid((_w.head * newDoc).toDenseMatrix.t)
    val hideOuts = new Array[SDM](_w.size)
    hideOuts(0) = z
    (1 until _w.size).map{
      i => 
        hideOuts(i) = wxpbS(_w(i),hideOuts(i-1))
    }
    hideOuts//.toDenseMatrix.t
  }///   def encode(_wIn: SDM, _doc : SDoc ): SDM ={
  def passAway(_w: Array[SDM], _doc : SDV ): Array[SDM] = {
    val hideOuts = new Array[SDM](_w.size)
    hideOuts(0) = wxpbS(_w.head,_doc.toDenseMatrix.t)
    (1 until _w.size).map{
      i => 
        hideOuts(i) = wxpbS(_w(i), hideOuts(i-1))
    }
    hideOuts//.toDenseMatrix.t
  }///   def encode(_wIn: SDM, _doc : SDoc ): SDM ={
  
  def encode(_wIns : Array[SDM], _doc : SBRZV) : Array[SDM] = {
    _doc match {
      case doc : SDV => passAway(_wIns,doc)
      case doc : SSV => passAway(_wIns,doc)
    }
  }
  def decodeStacked(_wOuts : Array[SDM], 
    _hideOut: SDM, 
    _doc : SBRZV ) : (Array[SDM], SBRZV) = {
    val rst = _doc match {
      case doc : SDV => {
        val rst = passAway(_wOuts,_hideOut.toDenseVector)
        rst.init -> rst.last.toDenseVector.asInstanceOf[SBRZV]
      }
      case doc : SSV => {
        val hideRst = passAway(_wOuts.init,_hideOut.toDenseVector)
        val rstIndices = doc.index
        val wLast = _wOuts.last
        val hLast = BDM.vertcat(hideRst.last, b)
        val rstValues = rstIndices.map{
          i =>
            BrzSigmoid(wLast(i,::) * hLast)
        }
        val rstVector = new BSV(rstIndices,rstValues,doc.size)
        hideRst -> rstVector.asInstanceOf[SBRZV]//.toDenseVector.toDenseMatrix.t
      }
    }
    rst
  }///   def decode1(_wOut : SDM, _hideOut: SDM ) : SDM = {
  def decodeSigle(_wOuts : Array[SDM], 
    _hideOut: SDM, 
    _doc : SBRZV ) : SBRZV = {
    val rst = _doc match {
      case doc : SDV => passAway(_wOuts,_hideOut.toDenseVector).last.toDenseVector.asInstanceOf[SBRZV]
      case doc : SSV => {
        val rstIndices = doc.index
        val wLast = _wOuts.last
        val hLast = BDM.vertcat(_hideOut, b)
        val rstValues = rstIndices.map{
          i =>
            BrzSigmoid((wLast(i,::) * hLast).apply(0))
        }
        val rstVector = new BSV(rstIndices,rstValues,doc.size)
        rstVector.asInstanceOf[SBRZV]
      }
    }
    rst
  }///   def decode1(_wOut : SDM, _hideOut: SDM ) : SDM = {

  // def decode(_wOuts : Array[SDM], 
  //   _hideOut: SDM, 
  //   _doc : SBRZV ) : (Array[SDM], SBRZV) = {
  //   val rst = _doc match {
  //     case doc : SDV => {
  //       if(_wOuts.size > 1){
  //         val rst = passAway(_wOuts,_hideOut.toDenseVector)
  //         rst.init -> rst.last.toDenseVector.asInstanceOf[SBRZV]
  //       }
  //       else passAway(_wOuts,_hideOut.toDenseVector)
  //     }
  //     case doc : SSV => {
  //       if(_wOuts.size > 1){
  //         val hideRst = passAway(_wOuts.init,_hideOut.toDenseVector)
  //         val rstIndices = doc.index
  //         val wLast = _wOuts.last
  //         val hLast = hideRst.last
  //         val rstValues = rstIndices.map{
  //           i =>
  //             BrzSigmoid(wLast(i,::) * hLast)
  //         }
  //         val rstVector = new BSV(rstIndices,rstValues,doc.size)
  //         hideRst -> rstVector.asInstanceOf[SBRZV]
  //       }
  //       else {
  //         val rstIndices = doc.index
  //         val wLast = _wOuts.last
  //         val hLast = hideRst.last
  //         val rstValues = rstIndices.map{
  //           i =>
  //             BrzSigmoid(wLast(i,::) * hLast)
  //         }
  //         val rstVector = new BSV(rstIndices,rstValues,doc.size)
  //       }
  //     }
  //   }
  //   rst
  // }///   def decode(_wOut : SDM, _hideOut: SDM ) : SDM = {



  def FeedForwardStack( _inWs : Array[SDM], 
    _outWs : Array[SDM], 
    _in : SBRZV ) : (Array[SDM], (Array[SDM], SBRZV) )= {
    val a0 = encode(_inWs,_in)
    val a1 = decodeStacked(_outWs, a0.last, _in)
    a0 -> a1 
  }
  def FeedForwardSingle( _inWs : Array[SDM], 
    _outWs : Array[SDM], 
    _in : SBRZV ) : (Array[SDM], SBRZV) = {
    val a0 = encode(_inWs,_in)
    val a1 = decodeSigle(_outWs, a0.last, _in)
    a0 -> a1 
  }

  def calcLoss( _inDoc : SBRZV, _outDoc : SBRZV ) : Double = {
    val minuSDoc = _inDoc - _outDoc
    val powDoc = minuSDoc :* minuSDoc
    val loss = powDoc.sum / powDoc.size.toDouble
    loss
  }
  def Dif_sigmoid( _vec : SBRZV ) : SBRZV = {
    _vec match {
      case vec : SDV => 
        (BrzSigmoid(vec) :/ (-BrzSigmoid(vec) :+ 1d)).asInstanceOf[SBRZV]
      case vec : SSV => {
        val indices = vec.index
        val values = vec.index.map{
          i =>
            BrzSigmoid(vec(i)) / (1 - BrzSigmoid(vec(i)))
        }
        new BSV(indices,values,vec.size).asInstanceOf[SBRZV]
      }
    }
  }
  def calcErrorOut( _inDoc : SBRZV, _outDoc :SBRZV ) : SBRZV = {
    val minusVec = _inDoc - _outDoc
    val powVec = minusVec :* minusVec
    val loss = powVec.sum / powVec.size.toDouble
    println(s"Loss : ${loss}")
    minusVec :* Dif_sigmoid(_outDoc)
  }






























  def calcErrorHidden( _errOut : SDoc, _hideOut : SDM,  _wOut : SDM ) : SDM = {
    // val wOutT = _wOut.t
    // val res = MulDoc( wOutT, _errOut )
    val errorHidden = new SDM(_hideOut.rows,1)
    for(i <- 0 until _errOut.size){
      val k = _errOut(i)._1 -1
      val v = _errOut(i)._3
      for(j <- 0 until _hideOut.size){
        errorHidden(j,0) += _wOut(k,j) * v        
      }
    }
    val h = _hideOut :* ( 1.0 - _hideOut )
    errorHidden :*= h
    errorHidden
  }

  def updateWB(
    _wIn : SDM, 
    _wOut : SDM, 
    _errHidden : SDM, 
    _errOut : SDoc,
    _hideOut : SDM,    
    _doc : SDoc,
    _lr : Double ) : (SDM,SDM) = {
    val dIn = _wIn.copy * 0d
    // dIn(::,-1) += _wIn(::,-1)
    val dOut = _wOut.copy * 0d
    // dOut(::,-1) += _wOut(::,-1)
    for( i <- 0 until _doc.size ){
      val k = _doc(i)._1 -1
      val v = _doc(i)._3
      val vOut = _errOut(i)._3
      for( j <- 0 until _hideOut.size ){
        dIn(j,k) += v * _errHidden(j,0)
        // dIn(j,k) += (_wIn(j,k) * 2d)
        dOut(k,j) += vOut * _hideOut(j,0)
        // dOut(k,j) += (_wOut(k,j) * 2d)
        dIn(j,-1) = _errHidden(j,0)
        // dIn(j,-1) += (_wIn(j,-1) * 2d)
      }
      dOut(k,-1) = (vOut - _wOut(k,-1))
    }
    _wIn -= (dIn * _lr)
    _wOut -= (dOut * _lr)
    // _wIn -= (dIn :* 1.0 + _wIn * 2.0) * _lr
    // _wOut -= (dOut * _lr) + _wOut * 2.0 * _lr

    (_wIn,_wOut)
  }

  def NNBP( _w : Array[SDM], _inDoc : SDoc ) : (SDM,SDM) = {
    val (hideOut,docOut) = NNFF(_w,_inDoc)

    val loss = calcLoss(_inDoc,docOut)
    val errDoc = calcErrorOut(_inDoc,docOut)
    println(s"--\t--\tLine : ${errDoc.head._2}\tLoss : $loss\t--\t--")

    val errorHidden = calcErrorHidden( errDoc, hideOut, _w.last )

    val nW = updateWB( _w(0), _w(1), errorHidden, errDoc, hideOut, _inDoc, lr )
    (nW._1,nW._2)
  }

  def Matlab2Matrix( _data : SDocs ) : SDM = {
    val rowNum = _data.size
    val colNum = _data.map{
      doc =>
        doc.map( word => word._1 ).max
    }.max + 1
    val res = new SDM(rowNum,colNum)
    _data.foreach{
      doc => 
        doc.foreach{
          word =>
            res(word._2,word._1) = word._3
        }
    }
    res
  }

}


import breezeAE._
val v = new BSV(Array(1,3),Array(32,26d),5)
val v1 = BSV.vertcat(v,BSV(1d))
val k = new BDV(Array(1,2,3,4,5d))
val t = gaussianM(4,5,0,1)
val eggData : SDocs = (0 until 8).map{
  i =>
    Array((i+1,i+1,1d))
}.toArray
val eggData0 : SDocs = (0 until 8).map{
  i =>
    val doc = Array.fill[SWord](8)((0,0,0d)) 
    (0 until 8).map{
      j =>
      if(i != j) doc(j) = (j+1,i+1,0d)
      else doc(j) = (j,i,1d)
    }
    doc
}.toArray
val docs = eggData0
val aew = InitWeightGaussian(Array(8,3,8))
// val aew = InitWeightGaussian(Array(8,5,3,5,8))
val doc = docs.head
val paewh = aew.head.copy
val paewl = aew.last.copy
// NNBP(aew,doc)
(0 until 1000).map( i => docs.map{
    print( "iter : " + i )
    doc => NNBP(aew,doc)
  })
val enc = docs.map{
  doc => 
  val rDoc = doc
  val rNum = rDoc.head._2
  val rEnc = encode(aew.head,rDoc)
  (rNum,rEnc.map(_.round).toArray)
}
val dec = docs.map{
  doc => 
    val rDoc = doc
    val rNum = rDoc.head._2
    val rEnc = encode(aew.head,rDoc)
    val rDec = decode(aew.last,rEnc,rDoc)
    rNum -> rDec
}
